AWSTemplateFormatVersion: '2010-09-09'
Description: 'Credit Scoring Infrastructure - LocalStack Compatible'

Resources:
  # Kinesis Data Stream for Loan Applications
  ApplicationsStream:
    Type: AWS::Kinesis::Stream
    Properties:
      Name: LoanApplicationsStream
      ShardCount: 1
      RetentionPeriodHours: 24

  # DynamoDB Table for Approved Applications
  ApprovedApplicationsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: ApprovedApplications
      AttributeDefinitions:
        - AttributeName: application_id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: application_id
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: CreditScoringLambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaKinesisExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt ApprovedApplicationsTable.Arn
        - PolicyName: SageMakerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sagemaker:InvokeEndpoint
                Resource: '*'

  # Lambda Function for Credit Scoring
  CreditScoringLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CreditScoringLambda
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          DYNAMODB_TABLE: !Ref ApprovedApplicationsTable
          ENDPOINT_NAME: credit-scoring-endpoint
      Code:
        ZipFile: |
          import base64
          import json
          import os
          import uuid
          from datetime import datetime
          import boto3
          
          # Get environment variables
          DYNAMODB_TABLE = os.environ.get('DYNAMODB_TABLE', 'ApprovedApplications')
          ENDPOINT_NAME = os.environ.get('ENDPOINT_NAME', 'credit-scoring-endpoint')
          
          # Initialize clients
          dynamodb_client = boto3.client('dynamodb')
          
          def store_approved_application(application_id, score, payload, decision):
              """Store approved application in DynamoDB for loan processing"""
              try:
                  response = dynamodb_client.put_item(
                      TableName=DYNAMODB_TABLE,
                      Item={
                          'application_id': {'S': application_id},
                          'timestamp': {'S': datetime.now().isoformat()},
                          'credit_score': {'N': str(score)},
                          'decision': {'S': decision},
                          'application_data': {'S': str(payload)},
                      }
                  )
                  return response
              except Exception as e:
                  print(f"Error storing in DynamoDB: {e}")
                  return None
          
          def score_application(payload):
              """
              Credit scoring logic - calculates credit score (300-850 scale)
              Uses simple rule-based scoring for demo purposes
              """
              try:
                  # Parse application data (CSV format)
                  values = [float(x) for x in payload.split(',')]
                  
                  # Credit scoring factors:
                  # 1. Credit score (first value) - primary factor
                  # 2. Income (second value)
                  # 3. Debt-to-income ratio
                  # 4. Employment length
                  # 5. Delinquencies
                  
                  if len(values) >= 5:
                      base_credit_score = values[0]
                      income = values[1]
                      debt_to_income = values[2]
                      employment_length = values[3]
                      delinquencies = values[4]
                      
                      # Start with base credit score
                      final_score = base_credit_score
                      
                      # Adjust based on other factors
                      # Income adjustment (+/- 50 points)
                      if income > 80000:
                          final_score += 30
                      elif income < 30000:
                          final_score -= 30
                      
                      # Debt-to-income adjustment (+/- 40 points)
                      if debt_to_income < 0.3:
                          final_score += 20
                      elif debt_to_income > 0.5:
                          final_score -= 40
                      
                      # Employment adjustment (+/- 20 points)
                      if employment_length > 5:
                          final_score += 15
                      elif employment_length < 1:
                          final_score -= 20
                      
                      # Delinquencies penalty (-50 points per delinquency)
                      final_score -= delinquencies * 50
                      
                      # Ensure score is in valid range (300-850)
                      final_score = max(300, min(850, final_score))
                      
                      # Decision: APPROVED if score >= 502 (trained model cutoff)
                      decision = 'APPROVED' if final_score >= 502 else 'DECLINED'
                      
                      return {
                          'score': final_score,
                          'decision': decision
                      }
              except Exception as e:
                  print(f"Error in credit scoring: {e}")
              
              return {'score': 500, 'decision': 'DECLINED'}
          
          def lambda_handler(event, context):
              """Process loan applications from Kinesis stream"""
              declined_count = 0
              approved_count = 0
              records_processed = 0
              
              for record in event.get('Records', []):
                  try:
                      # Kinesis data is base64 encoded
                      payload = base64.b64decode(record['kinesis']['data']).decode('utf-8')
                      records_processed += 1
                      
                      # Generate application ID
                      application_id = str(uuid.uuid4())
                      
                      # Score the application
                      result = score_application(payload)
                      score = result['score']
                      decision = result['decision']
                      
                      # Store APPROVED applications in DynamoDB for loan processing
                      if decision == 'APPROVED':
                          store_approved_application(application_id, score, payload, decision)
                          approved_count += 1
                          print(f"✅ APPROVED - Application {application_id[:8]} (score: {score:.0f})")
                      else:
                          declined_count += 1
                          print(f"❌ DECLINED - Application {application_id[:8]} (score: {score:.0f})")
                      
                  except Exception as e:
                      print(f"Error processing record: {e}")
                      continue
              
              message = f"Processed {records_processed} applications: {approved_count} approved, {declined_count} declined"
              print(message)
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': message,
                      'records_processed': records_processed,
                      'approved': approved_count,
                      'declined': declined_count
                  })
              }

  # Event Source Mapping: Kinesis -> Lambda
  KinesisEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt ApplicationsStream.Arn
      FunctionName: !Ref CreditScoringLambda
      StartingPosition: LATEST
      BatchSize: 10
      MaximumBatchingWindowInSeconds: 5

Outputs:
  KinesisStreamName:
    Description: Name of the Kinesis stream for loan applications
    Value: !Ref ApplicationsStream
    Export:
      Name: LoanApplicationsStreamName

  KinesisStreamArn:
    Description: ARN of the Kinesis stream
    Value: !GetAtt ApplicationsStream.Arn
    Export:
      Name: LoanApplicationsStreamArn

  DynamoDBTableName:
    Description: Name of the DynamoDB table for approved applications
    Value: !Ref ApprovedApplicationsTable
    Export:
      Name: ApprovedApplicationsTableName

  LambdaFunctionName:
    Description: Name of the Lambda function
    Value: !Ref CreditScoringLambda
    Export:
      Name: CreditScoringLambdaName

  LambdaFunctionArn:
    Description: ARN of the Lambda function
    Value: !GetAtt CreditScoringLambda.Arn
    Export:
      Name: CreditScoringLambdaArn

